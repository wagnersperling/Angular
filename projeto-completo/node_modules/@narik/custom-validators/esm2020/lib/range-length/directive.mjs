import { Directive, Input, forwardRef, } from '@angular/core';
import { NG_VALIDATORS, } from '@angular/forms';
import { rangeLength } from './validator';
import * as i0 from "@angular/core";
const RANGE_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => RangeLengthValidator),
    multi: true,
};
export class RangeLengthValidator {
    ngOnInit() {
        this.validator = rangeLength(this.rangeLength);
    }
    ngOnChanges(changes) {
        for (const key in changes) {
            if (key === 'rangeLength') {
                this.validator = rangeLength(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
RangeLengthValidator.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: RangeLengthValidator, deps: [], target: i0.ɵɵFactoryTarget.Directive });
RangeLengthValidator.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.0.0", type: RangeLengthValidator, selector: "[rangeLength][formControlName],[rangeLength][formControl],[rangeLength][ngModel]", inputs: { rangeLength: "rangeLength" }, providers: [RANGE_LENGTH_VALIDATOR], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: RangeLengthValidator, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rangeLength][formControlName],[rangeLength][formControl],[rangeLength][ngModel]',
                    providers: [RANGE_LENGTH_VALIDATOR],
                }]
        }], propDecorators: { rangeLength: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmFyaWstY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2xpYi9yYW5nZS1sZW5ndGgvZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsS0FBSyxFQUNMLFVBQVUsR0FJYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0gsYUFBYSxHQUloQixNQUFNLGdCQUFnQixDQUFDO0FBRXhCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxhQUFhLENBQUM7O0FBRTFDLE1BQU0sc0JBQXNCLEdBQVE7SUFDaEMsT0FBTyxFQUFFLGFBQWE7SUFDdEIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQztJQUNuRCxLQUFLLEVBQUUsSUFBSTtDQUNkLENBQUM7QUFPRixNQUFNLE9BQU8sb0JBQW9CO0lBTTdCLFFBQVE7UUFDSixJQUFJLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUM5QixLQUFLLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBRTtZQUN2QixJQUFJLEdBQUcsS0FBSyxhQUFhLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDeEQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNmLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztpQkFDbkI7YUFDSjtTQUNKO0lBQ0wsQ0FBQztJQUVELFFBQVEsQ0FBQyxDQUFrQjtRQUN2QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELHlCQUF5QixDQUFDLEVBQWM7UUFDcEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQzs7aUhBM0JRLG9CQUFvQjtxR0FBcEIsb0JBQW9CLG1KQUZsQixDQUFDLHNCQUFzQixDQUFDOzJGQUUxQixvQkFBb0I7a0JBTGhDLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUNKLGtGQUFrRjtvQkFDdEYsU0FBUyxFQUFFLENBQUMsc0JBQXNCLENBQUM7aUJBQ3RDOzhCQUVZLFdBQVc7c0JBQW5CLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgRGlyZWN0aXZlLFxyXG4gICAgSW5wdXQsXHJcbiAgICBmb3J3YXJkUmVmLFxyXG4gICAgT25Jbml0LFxyXG4gICAgT25DaGFuZ2VzLFxyXG4gICAgU2ltcGxlQ2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtcclxuICAgIE5HX1ZBTElEQVRPUlMsXHJcbiAgICBWYWxpZGF0b3IsXHJcbiAgICBWYWxpZGF0b3JGbixcclxuICAgIEFic3RyYWN0Q29udHJvbCxcclxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5pbXBvcnQgeyByYW5nZUxlbmd0aCB9IGZyb20gJy4vdmFsaWRhdG9yJztcclxuXHJcbmNvbnN0IFJBTkdFX0xFTkdUSF9WQUxJREFUT1I6IGFueSA9IHtcclxuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYW5nZUxlbmd0aFZhbGlkYXRvciksXHJcbiAgICBtdWx0aTogdHJ1ZSxcclxufTtcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6XHJcbiAgICAgICAgJ1tyYW5nZUxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbcmFuZ2VMZW5ndGhdW2Zvcm1Db250cm9sXSxbcmFuZ2VMZW5ndGhdW25nTW9kZWxdJyxcclxuICAgIHByb3ZpZGVyczogW1JBTkdFX0xFTkdUSF9WQUxJREFUT1JdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUmFuZ2VMZW5ndGhWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcclxuICAgIEBJbnB1dCgpIHJhbmdlTGVuZ3RoOiBbbnVtYmVyLCBudW1iZXJdO1xyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuICAgIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSByYW5nZUxlbmd0aCh0aGlzLnJhbmdlTGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAncmFuZ2VMZW5ndGgnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHJhbmdlTGVuZ3RoKGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XHJcbiAgICB9XHJcbn1cclxuIl19